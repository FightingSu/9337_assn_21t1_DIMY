# library for ECDH
from third_party.ecdsa import ECDH, SECP128r1, VerifyingKey

# library for generating murmur hash
from third_party.pymmh3 import hash as mmhash32

# bitarray, used in bloom_filter
from bitarray import bitarray

# random number
from random import randint

# network related libraries
import socket
import requests
from requests.exceptions import Timeout
import json
from base64 import b64encode

# multi-thread related
from time import sleep
from threading import Thread

# sss
from third_party.sss import create_shares, combine_shares

# default list
from collections import defaultdict

# use sys.byteorder
import sys

# import for the backend server
import os
sys.path.insert(1, os.path.join(sys.path[0], '..'))
from pprint import pprint

def query_contact (QBF, url):
    data = json.dumps({"QBF": "{}".format(b64encode(QBF.bitarr.tobytes()))})
    headers={"Content-Type":"application/json"}
    try:
        response = requests.post(url, data=data, headers=headers)
    except Timeout:
        print("----- Timeout error, retrying... -----")
        return ''
    else:
        return response.text

def upload_contact (CBF, url):
    data = json.dumps({"CBF": "{}".format(b64encode(CBF.bitarr.tobytes()))})
    headers={"Content-Type":"application/json"}
    try:
        response = requests.post(url, data=data, headers=headers)
    except Timeout:
        print("----- Timeout error, retrying... -----")
        return ''
    else:
        return response.text

# used when debugging
def bytearr_hex_to_str(bytearr_key: bytearray):
    return bytearr_key.hex()

# used when debugging
def str_hex_to_bytearr(str_key: str):
    return bytearray.fromhex(str_key)

# generate murmur hash in 3 bytes
def murmurhash(pub_key: bytearray):
    hash_val = mmhash32(pub_key, seed=randint(0, 100000000))
    hash_val_bytearr = hash_val.to_bytes(4, sys.byteorder, signed=True)[:3]
    return hash_val_bytearr


class bloom_filter(object):
    # m is the size of the filter
    # k is the number of hashes
    # n is the number of entries to be stored
    def __init__(self, m, k, n):
        self.filter_size = m
        self.num_hashes = k
        self.num_entries = n
        self.bitarr = bitarray(self.filter_size)
        self.bitarr.setall(0)
    
    def put(self, item):
        pos = []
        for i in range(0, self.num_hashes):
            map_to = mmhash32(item, i + 2048) % self.filter_size
            self.bitarr[map_to] = True
            pos.append(map_to)
        return pos
    
    def get(self, item):
        for i in range(0, self.num_hashes):
            map_to = mmhash32(item, i + 2048) % self.filter_size
            if self.bitarr[map_to] == False:
                return False
            
        return True

    @staticmethod
    def combine_filters(filters: list):
        bf = bloom_filter(filters[0].filter_size, filters[0].num_hashes, filters[0].num_entries)
        for f in filters:
            bf.bitarr |= f.bitarr
        return bf
        

'''
A simple recource manager managing the
generation of ephid and encid.
'''
class enc_mgr(object):
    def __init__(self):
        self.mgr = ECDH(curve=SECP128r1)
        self.mgr.generate_private_key()
        self.priv_key = self.mgr.private_key.to_string()
        self.pub_key = self.mgr.get_public_key().to_string("compressed")[1:]
        self.mmh32 = murmurhash(self.pub_key)  # the hash value
    
    #EchID
    def get_shared(self, pub_key: str):
        restored_key = bytearray.fromhex('02') + pub_key
        restored_key = VerifyingKey.from_string(restored_key, curve=SECP128r1)
        self.mgr.load_received_public_key(restored_key)
        hex_encid = hex(self.mgr.generate_sharedsecret())[2:]
        prefix = "0" * (32 - len(hex_encid))
        hex_encid = prefix + hex_encid
        return bytearray.fromhex(hex_encid)

    def new_priv_key(self):
        self.mgr.generate_private_key()
        self.priv_key = self.mgr.private_key.to_string()
        self.pub_key = self.mgr.get_public_key().to_string("compressed")[1:]
        self.mmh32 = murmurhash(self.pub_key)




'''
Object that sends out ephid and receive from others.
'''
class client(object):
    def __init__(self, port):
        # broadcasting port
        self.port = port

        # encounter id manager
        self.encmgr = enc_mgr()

        # ephid broadcast count
        # if one ephid broadcasted many times
        # generate a new one instead
        # (use enc_mgr.new_priv_key())
        # and reset ephid_cnt
        self.ephid_cnt = 0

        # fragments generated by shamir's secret sharing
        # for broadcasting
        self.msg = create_shares(self.encmgr.pub_key)

        # broadcasting thread
        self.broadcast_thread = Thread(target=self.send)

        # listening thread
        self.monitor_thread = Thread(target=self.listen)

        # backend communicate thread
        # QBF will be sent to the backend server, and get the result
        self.backend_thread = Thread(target=self.backend_communication)

        # key is hash of ephid received, NOT IP ADDRESS
        # value is the fragment of ephid
        #
        # it shall looks like:
        # { 
        #     "2efda":
        #     {
        #         1: "23abd2fda",
        #         2: "1092fdace",
        #     }
        # }
        # 
        # when complete ephid received, restore ephid and
        # move it in self.ephid_complete
        self.ephid_frag = defaultdict(list)

        # complete ephids
        self.ephid_complete = defaultdict(list)

        # create a bloom filter
        print("======= create a new Contact BloomFilter (every 10 minutes will create a new one, maximum 6 CBFs) ======= \n")
        self.DBFs = bloom_filter(800000,2,1000)
        self.DBFs_list = []


    # start broadcasting and monitoring
    def start_service(self):
        self.broadcast_thread.start()
        self.monitor_thread.start()
        self.backend_thread.start()
        print(">>>>> Service start working, client is working on UDP port {} <<<<<\n".format(self.port))

    # listen to others' broadcast
    # the listen function should perform shamir's secret sharing
    # we use self.ephid_complete_check() to perform such operation
    # and tries to restort ephid from fragments received
    # the hashid can't be decoded by utf-8, so when a message is recieved
    # kick out the hashid from the end of the message. Hashid's length is 3 byte
    def listen(self):
        #print("function 'listen' not finished!")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        s.bind(('', self.port))
        print(f"Listening for broadcast at {s.getsockname()}")
        while True:
            data, address = s.recvfrom(1024)
            recived_hashid = data[-3:]
            data = data[0:-4]
            # print('Server received from {}: {}'.format(address, data.decode('utf-8')))
            print('Segment 3-B, received share: {}'.format(data))
            self.ephid_complete_check(data.decode('utf-8'),recived_hashid)
        
    # broadcast
    # the send function should generate new ephid when needed
    # we use self.ephid_cnt_check() function to check whether a new 
    # ephid should be generated
    def send(self):
        # print("function 'send' not finished!")
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        network = '<broadcast>'
        # hashid = self.encmgr.mmh32
        while(True):
            # print the values
            print("------------------> Segment 1 <------------------")
            print(" generate EphID:{}".format(self.encmgr.pub_key))
            print(" hash value of EphID: {}\n".format(self.encmgr.mmh32))
            if(len(self.msg) == 6):
                print("------------------> Segment 2 <------------------")
                print("Six Shares:")
                for i in self.msg:
                    print(i.encode('utf8'))


            share_hash = self.msg.pop().encode('utf-8') + ' '.encode('utf-8') + self.encmgr.mmh32

            print('Segment 3-A, sending share: {}\n'.format(share_hash))
            print(self.encmgr.mmh32)
            s.sendto(share_hash, (network, self.port))
            self.ephid_cnt_check()
            sleep(1)
    
    def backend_communication(self):
        while(True):
            if( self.ephid_cnt == 24):
                six_filters = bloom_filter.combine_filters(self.DBFs_list)
                print("uploading QBF to backend server...")
                result = query_contact(six_filters, 'http://ec2-3-26-37-172.ap-southeast-2.compute.amazonaws.com:9000/comp4337/qbf/query')
                pprint(result)
                result = upload_contact(six_filters, 'http://ec2-3-26-37-172.ap-southeast-2.compute.amazonaws.com:9000/comp4337/cbf/upload')
                pprint(result)
        




    def ephid_cnt_check(self):
    #    print("function 'ephid_cnt_check' not finished!")
        self.ephid_cnt = self.ephid_cnt + 1
        print("{} messages have been sent".format(self.ephid_cnt))
        #for every 10 minutes, a new bloom filter will be created
        # 600
        if (self.ephid_cnt % 12 ==0):
            # print("It's 10 minutes, generate a new daily bloom filter!")
            self.DBFs_list.append(self.DBFs)
            self.DBFs = bloom_filter(800000,2,1000)

        if (self.ephid_cnt % 6 == 0 ):
            self.encmgr.new_priv_key()
            # self.ephid_cnt = 0
            self.msg = create_shares(self.encmgr.pub_key)
            self.encmgr.mmh32 = self.encmgr.mmh32
            # print('Generate new ID') 

        # if one hour passes, the first element in DBFs_list will be deleted
        if (len(self.DBFs_list) == 6):
            self.DBFs_list.pop(0)
        
        # every hour upload the 6 bloom filters
        # 3600 
        if (self.ephid_cnt == 24):
            self.ephid_cnt = 0




    def ephid_complete_check(self, fragments,hashid):
        # print("function 'ephid_complete_check' not finished!")
        # the key is app's hashid and value is the sare messages.
        # Once get 3 or more than 3 messages from a same hashid, decode its EphID.
        # And then move this EphId into ephid_complete
        # delete this id from the this dictionary
        self.ephid_frag[hashid].append(fragments)
        completed = []

        # print how many shares are recieved
        tmp = 0
        for i in  self.ephid_frag:
            tmp = tmp + len(self.ephid_frag[i])
            print("Segment 3-C, total shares received: {}".format(tmp))

        for i in  self.ephid_frag:
            if len(set(self.ephid_frag[i])) >= 3:
                print("------------------> Segment 4 <------------------\n")
                # decode the EphID 
                true_id = combine_shares(self.ephid_frag[i][0:3])
                print("Segment 4-A, re-construct EphID: {}".format(true_id))
                r_hashid = murmurhash(true_id)
                print("Segment 4-B, hash value of re-constructed EphID: {} is equal to hash value of original EphID: {}".format(r_hashid,hashid))


                #generate the EncID
                encid = self.encmgr.get_shared(true_id)
                print("------------------> Segment 5 <------------------\n")
                print("generate shared secret EncID: {}".format(encid))

                # put the EncID into the bloom filter then delete the EncID
                print("======== insert into DBF (murmur3 hashing with 3 hashes) ========\n")
                self.DBFs.put(encid)
                del encid

                # result = query_contact(self.DBFs, 'http://ec2-3-26-37-172.ap-southeast-2.compute.amazonaws.com:9000/comp4337/qbf/query')
                # pprint(result)
                # result = upload_contact(self.DBFs, 'http://ec2-3-26-37-172.ap-southeast-2.compute.amazonaws.com:9000/comp4337/cbf/upload')
                # pprint(result)
                
                self.ephid_complete[len(self.ephid_complete) + 1].append(true_id)
                completed.append(i)
        
        # delete the hashid from this dictionary
        # array completed contain all the decoded EphID
        for i in completed:
            del self.ephid_frag[i]
                